# [IGP에서의 Shortest Path Algorithm](https://growth-coder.tistory.com/194)
### IGP Routing Algorithm 2가지 : OSFP ( Link State ), RIP ( Distance Vector Algorithm )
#### OSFP ( Link State ) : 각 라우터가 전체 네트워크의 토폴로지 정보를 수집하고 유지하는 라우팅 알고리즘
- Dijkstra's Algorithm 사용
#### RIP ( Distance Vector Algorithm ) : 각 라우터가 자신의 이웃 라우터로부터 받은 정보를 기반으로 목적지까지의 거리와 방향을 결정하는 라우팅 알고리즘
 - Bellman-Ford Algorithm 사용
### [Dijkstra's Algorithm](https://m.blog.naver.com/ndb796/221234424646) (OSFP)
- 특징

    출발점에서 다른 모든 노드까지의 최단 경로를 찾는 알고리즘
    음의 가중치를 가진 간선이 없는 그래프에서 사용
    그리디(Greedy) 방식으로 동작


- 시간 복잡도: O(V^2) 또는 O(E log V) (우선순위 큐 사용 시)

- OSPF가 Dijkstra's Algorithm을 사용하는 이유:

    - 빠른 수렴 시간: Dijkstra's Algorithm은 그리디 방식으로 동작하여 빠르게 최단 경로를 찾을 수 있음

    - 정확성: 전체 네트워크 토폴로지 정보를 바탕으로 정확한 최단 경로를 계산

    - 확장성: 대규모 네트워크에서도 효율적으로 동작

    - 루프 방지: Link State 방식으로 동작하여 라우팅 루프를 방지

    - 빠른 재계산: 네트워크 변화 시 빠르게 새로운 경로를 계산할 수 있음

### [Bellman-Ford Algorithm](https://velog.io/@kimdukbae/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B2%A8%EB%A7%8C-%ED%8F%AC%EB%93%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Bellman-Ford-Algorithm) (RIP)
- 특징

    한 노드에서 다른 모든 노드까지의 최단 경로를 찾는 알고리즘
    음의 가중치를 가진 간선이 있는 그래프에서도 사용 가능
    음의 사이클 탐지 가능


- 시간 복잡도: O(VE)

- RIP가 Bellman-Ford Algorithm을 사용하는 이유:

    - 간단한 구현: Bellman-Ford Algorithm은 구현이 상대적으로 간단함

    - 분산 처리: 각 라우터가 독립적으로 계산을 수행할 수 있어 분산 환경에 적합

    - 점진적 업데이트: 주기적으로 이웃 라우터와 정보를 교환하며 점진적으로 라우팅 테이블을 업데이트

    - 소규모 네트워크 적합: 작은 네트워크에서 효과적으로 동작함

    - 하위 호환성: 오래된 네트워크 장비와의 호환성이 좋음

### OSPF (Dijkstra's Algorithm)와 RIP (Bellman-Ford Algorithm)의 선택 이유 비교:

- 네트워크 규모: OSPF는 대규모 네트워크에 적합하고, RIP는 소규모 네트워크에 적합
- 수렴 속도: OSPF가 RIP보다 빠르게 수렴
- 리소스 사용: OSPF는 더 많은 메모리와 CPU를 사용하지만, 더 효율적인 라우팅을 제공
- 구현 복잡도: RIP는 구현이 간단하지만, OSPF는 더 복잡함
- 확장성: OSPF가 RIP보다 더 나은 확장성을 제공

- 네트워크의 규모, 복잡도, 요구사항에 따라 OSPF나 RIP를 선택하게 되며, 이에 따라 Dijkstra's Algorithm 또는 Bellman-Ford Algorithm이 사용됨
