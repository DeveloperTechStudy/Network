# 05(2) 응용계층

# 05-2 HTTP (292p)

<aside>
✅ 응용 계층

</aside>

<aside>
☑️ 전송 계층

</aside>

<aside>
☑️ 네트워크 계층

</aside>

<aside>
☑️ 데이터 링크 계층

</aside>

<aside>
☑️ 물리 계층

</aside>

## HTTP 상태 코드

### 상태코드

<aside>
<img src="https://www.notion.so/icons/dialogue_red.svg" alt="https://www.notion.so/icons/dialogue_red.svg" width="40px" /> 상태코드가 뭔가요?

</aside>

<aside>
<img src="https://www.notion.so/icons/alert_green.svg" alt="https://www.notion.so/icons/alert_green.svg" width="40px" /> 상태 코드는 요청에 대한 결과를 나타내는 세 자리 정수입니다.

</aside>

상태코드는 백의 자리 수를 기준으로 유형을 구분할 수 있습니다.
유사한 상태코드는 같은 백의 자리 수를 공유합니다.

| 상태코드 | 설명 |
| --- | --- |
| 100번대 (100~199) | 정보성 상태 코드 |
| 200번대 (200~299) | 성공 상태 코드 |
| 300번대 (300~399) | 리다이렉션 상태 코드 |
| 400번대 (400~499) | 클라이언트 에러 상태 코드 |
| 500번대 (500~599) | 서버 에러 상태 코드 |

### 200번대: 성공 상태 코드

---

200번대 상태 코드는 `요청이 성공했음`을 의미합니다.

| 상태코드 | 이유 구문 | 설명 |
| --- | --- | --- |
| 200 | OK | 요청이 성공했음 |
| 201 | Created | 요청이 성공했으며, 새로운 자원이 생성되었음 |
| 202 | Accepted | 요청을 잘 받았으나, 아직 요청한 작업을 끝내지 않았음 |
| 204 | No content | 요청이 성공했지만, 메시지 본문으로 표시할 데이터가 없음 |

### 300번대: 리다이렉션 상태 코드

---

리다이렉션(Redirection)이란? 인터넷 공식 문서에는 “요청을 완수하기 위해 추가적인 조치가 필요한 상태”로 정의합니다.

단어 자체를 풀어 설명하면 `“Re” 다시 + “Direct” 향하다` 즉, 리다이렉션은 클라이언트가 요청한 자원이 다른 곳에 있을 때, 클라이언트의 요청을 다른 곳으로 이동시키는 것을 의미합니다.

클라이언트가 요청한 자원이 다른 URL에 있을 경우, 서버는 응답 메시지의 Location 헤더를 통해 요청한 자원이 위치한 URL을 안내해 줄 수 있습니다. 이를 수신한 클라이언트는 Location 헤더에 명시된 URL로 즉시 재요청을 보내어 새로운 URL에 대한 응답을 받게 됩니다.

**영구적인 리다이렉션**

자원이 완전히 새로운 곳으로 이동하여 경로가 **영구적으로** 재지정되는것

| 상태 코드 | 이유 구문 | 설명 |
| --- | --- | --- |
| 301 | Moved Permanently | 영구적 리다이렉션: 재요청 메서드 변경될 수 있음 |
| 308 | Permanent Redirect | 영구적 리다이렉션: 재요청 메서드 변경되지 않음 |
- 클라이언트가 서버에 GET요청 메시지를 보낸 뒤 301혹은 308 응답 메시지를 받았고, 응답 메시지의 Locartion 헤더에 명시된 경로로 재요청을 보내야 한다고 가정해보겠습니다. 이 경우 클라이언트가 보내는 두 번째 요청 메서드는 첫 번째 요청 메서드와 동일하게 GET입니다.
- 클라이언트가 서버에 POST 메서드와 같이 GET 메서드가 아닌 요청 메시지를 보냈고, 301응답 메시지를 받았다고 해 봅시다. 이 경우 클라이언트가 보내는 두 번째 요청 메서드는 GET요청으로 바뀔 수도 있습니다.
이런 애매함으로 인해 등장한 코드가 308입니다. 클라이언트가 308응답 메시지를 받을 경우, 두 번째 요청 메서드는 변하지 않습니다.

일시적인 리다이렉션

자원의 위치가 임시로 변경되었거나 임시로 사용한 URL이 필요한 경우에 주로 사용됩니다.

| 상태 코드 | 이유 구문 | 설명 |
| --- | --- | --- |
| 302 | Found | 일시적 리다이렉션: 재요청 메서드 변경될 수 있음 |
| 303 | See Other | 일시적 리다이렉션: 재요청 메서드 GET으로 변경 |
| 3078 | Temporary Redirect | 일시적 리다이렉션: 재요청 메서드 변경되지 않음 |
- 영구적인 리다이렉션의 301과 일시적인 리다이렉션의 302는 매우 유사합니다. “완전히 이동하였음”과 “일시적으로 이동하였음”을 나타낸다는 정도의 차이가 있습니다.
- 위에서 GET이 아닌 요청을 받은 메서드가 301코드를 받은 경우 GET으로 변경될수도 있다고 했었습니다. 상태코드 302도 마찬가지 입니다. GET이 아닌 요청 메서드를 사용한 클라이언트가 상태코드 302를 응답받은 경우, 두 번째 요청 메서드는 GET으로 바뀔수도 있습니다. 301의 애매모호함을 해결하기 위한 상태코드가 308인 것처럼, 상태 코드 302의 애매모호함을 해결하기 위한 상태 코드는 307입니다. 307은 두 번째 요청 메서드를 변경하지 않는 상태코드 입니다.
예를 들어, POST 요청을 보낸 클라이언트가 307을 응답받을 경우, 두 번째 요청 메서드도 POST로 유지됩니다. 한 편으로, 두 번째 요청 메서드를 반드시 유지하는 상태 코드 307과 달리 303은 두 번째 요청 메서드를 GET으로 바꿔 주기 위해 사용됩니다.
- 리디렉션이란, 클라이언트가 요청한 자원이 ‘다른곳’에 있을 때, 클라이언트의 요청을 ‘다른 곳’으로 이동시키는 것이라도 했습니다. 여기서 말하는 ‘다른 곳’은 다른 URL이 될 수도 있고, 다음 절에서 학습할 캐시가 될 수도 있습니다. 지금까지의 설명은 전자와 관련한 설명입니다. 다시말해 클라이언트가 요청한 자원이 다른 URL에 있을 때, 클라이언트의 요청을 해당 URL로 이동시키는 상태 코드를 설명했습니다. 다음 절에서는 캐시와 관련된 상태 코드인 304를 학습할 예정입니다. 지금은 304는 ‘ 자원이 변경되지 않았음’을 의미하는 상태 코드이며, 캐시와 관련된 상태코드라는 정도로 알아두면 됩니다.

### 400번대: 클라이언트 에러 상태 코드

---

400번대 상태코드는 ‘클라이언트에 의한 에러가 있음’을 알려주는 상태 코드입니다.
서버가 처리할 수 없는 형태로 요청을 보냈거나, 존재하지 않는 자원에 대해 요청을 보내는 경우가 이런 경우에 속합니다.

그 유명한 404(Not Found)가 바로 400번대, 클라이언트 에러 상태코드의 일종입니다.

| 상태 코드 | 이유 구문 | 설명 |
| --- | --- | --- |
| 400 | Bad Request |  클라이언트의 요청이 잘못되었음 |
| 401 | Unauthorized | 요청한 자원에 대한 유효한 인증이 없음 |
| 403 | Forbidden | 요청이 서버에 의해 거부됨
(예: 접근 권한이 없을 경우) |
| 404 | Not Found | 요청받은 자원을 찾을 수 없음 |
| 405 | Method Not Allowed |  요청한 메소드를 지원하지 않음 |
- 상태 코드 400은 클라이언트의 요청이 잘못되었음을 알려 주는 상태 코드 입니다. 클라이언트 요청 메세지에 내용이나 형식 자체의 문제가 있어 서버에 요청 메세지를 올바르게 처리할 수 없는 경우가 이런 상황에 속합니다.
- 웹 상에서 정보를 검색할 때 모든 자원을 접근이 가능한 것은 아닙니다. 때로는 특정 자원의 접근 하기 위해 인증이 필요할 때가 있습니다. 요청에 대한 인증이 필요할 경우 서버는 401 상태 코드를 응답 할 수 있습니다.
    - 서버가 상태 코드 401로 응답 할 때는 한가지 특징이 있습니다. www authenticate라는 헤더를 통해 인증 방법을 알려 주어야 한다는 점입니다. 이것은 다음 절에서 자세히 알아 보겠습니다.
- 만약 클라이언트에 권한이 충분하지 않다면 상태코드 403을 응답 합니다. 즉 즉 상태 코드 403은’ 자원의 접근 할 권한이 없음’ 을 의미합니다.
    - 상태 코드 401을 혼동 하기 쉬운데 인증 여부와 권한 부여 여부는 다른 개념 입니다
     인증이란 자신이 누구인지 증명 하는 것을 의미하고.
     권한 부여는 인증된 주체에게 작업을 허용 하는 것을 의미합니다. 인가 라고도 부릅니다. 인증이 되었더라도 권한이 충분하지 않을 수 있습니다.
- 상태코드 404는 접근 하고자 하는 자원이 존재하지 않음을 알리는 상태 코드 입니다. 존재 하더라도 공개 하지 않는 자원에 대해 사 공사를 응답 하는 경우도 있습니다.
- 앞서 말한 것처럼 어떤 URI(URL)에 어떤 메서드로 요청을 받았을 때 서버가 어떻게 행동 또는 응답을 해야 하는지 설계 하는 것은 오로지 개발 자의 욕심으로 일부 메소드는 구현 되어 있지 않을 수도 있습니다. 구현 되지 않은 메소드를 요청을 보낸다면 상태코드 405를 통해 해당 메세지에 미지원을 알릴 수 있습니다.

### 500번대: 서버 에러 상태 코드

---

400번대 상태 코드의 원인이 클라이언트라면 500번대 상태 코드의 원인은 서버 입니다.

즉 500 번째 오류는 클라이언트가 올바르게 요청을 보냈을지라도 발생할 수 있는 서버 에러에 대한 상태 코드 입니다

| 상태 코드 | 이유 구문 | 설명 |
| --- | --- | --- |
| 500 | Internet Server Error |  요청을 처리 할 수 없음 |
| 502 | Bad Gateway |  중간 서버의 통신 오류 |
| 503 | Service Unavailable | 현재는 요청을 처리할 수 없으나 추후 가능할 수도 있음 |
- 500 번대. 상태 코드 중에서 자주 사용되는 상태 코드는 500 입니다. 이는.’ 서버의 예기치 못한 상황으로 인해 요청을 처리 할 수 없음.’ 이라는 의미 입니다. 다소 포괄적인 표현이라 서버의 에러를 통칭 하기도 합니다.
- 상태 코드 502는 클라이언트와 서버 사이에 위치한 중간 서버에 통신 오류를 나타내는 상태 코드 입니다. 클라이언트와 서버는 일반적으로 일대일로 연결 되어 통신 하지 않습니다. 클라이언트와 서버 사이에는 게이트웨이를 비롯한 여러 중간 서버가 존재할 수 있습니다. 클라이언트와 서버가 요청과 응답을 주고 받는 과정에서 중간에 위치한 수많은 서버들도 요청과 응답을 주고 받게 됩니다.
 이때 클라이언트와 서버 사이에 위치한 중간 서버가 유효 하지 않거나 잘못된 응답을 받을 수도 있습니다. 이럴 때 상태코드 502을 응답 합니다.
- 마지막으로 상태코드 503은’ 현재 서비스를 일시적으로 이용할 수 없음’을 의미하는 상태 코드 입니다. 서버가 과부하 상태 있거나 일시적인 점검 상태일때 볼 수 있는 상태 코드 입니다.

여기까지가 HTTP응답 메세지의 상태 코드에 대해 알아 보았습니다.

## HTTP 의 발전: HTTP/0.9에서 HTTP/3.0 까지

### HTTP/0.9

0.9는 지금은 거의 사용 되지 않는 초창기 HTTP버전 입니다. 사용 가능한 메소드가 GET뿐이었고, 요청 메세지는 한 줄로 구성 되어 있었습니다. 헤더가 지원 되지 않았습니다.

### HTTP/1.0

1.0 에서는 HEAD, POST 와 같은 GET 이외의 메소드가 도입 되었고, 헤더가 지원 되기 시작해 훨씬 더 다양한 정보를 주고 받을 수 있게 되었습니다. 그러나 여전히 공식적으로는 지속 연결을 지원 하지 않았습니다. 다시 말해 HTTP 메시지를 주고 받을때마다 연결을 수립하고 종료 하기를 반복 했습니다.

### HTTP/ 1.1

1.1 부터 지속 연결이 공식적으로 지원 되었습니다. 또한 특정 요청에 대한 응답이 수신 되기 전에 다음 요청을 보낼 수 있는 파이프 라이닝 기능과같은 다양한 편의 기능 및 사용 가능한 헤더가 추가 되었습니다. 오늘날까지 널리 사용되는 버전 입니다.

### HTTP/2.0

2.0은 1.1의 효율과 성능을 높이기 위한 버전 입니다. 달리 말하자면 1.1을 보완하고 개선하기 위한 버전으로 볼 수 있습니다. 2.0 에서는 송수신 효율을 높이기 위해 헤더를 압축하여 전송 하고 바이너리 데이터 기반의 메시지를 송수신 합니다. 이전버전에서는 텍스트 기반의 메시지를 송수신 했습니다. 또 클라이언트가 요청 하지 않았더라도 미래에 필요할 것으로 예상되는 자원을 미리 전송 해 주는 서버 푸쉬 라는 기능을 제공 하기도 합니다.

그리고 2.0은 1.1 까지의 고질적인 문제였던 H O L 블로킹이라는 문제를 완화 한 버전이기도 합니다. H O L 블로킹이란.’ 같은 큐에 대기하며 순차적으로 처리 되는 여러 패키지 있을 때 첫 번째 패킷을 처리 지연으로 인해 나머지 패기들을 처리도 모두 지연 되는 문제 상황’ 을 의미합니다.
여기서 큐는 한 줄로 저장된 값이 저장된 순서대로 처리 되는 일종의 대기열이라고 보면 됩니다.
 HTTP 에서 발생하는 HOL 블로킹 양상은 다음과 같습니다. 그림을 보면 알 수 있듯이 서버가 요청 B, C를 빠르게 처리할 수 있더라도 요청 A의 처리가 지연 되면 요청 B, C의 처리속도도 지연됩니다.

![2FDDB8F6-7AA1-4E2F-83C9-A7DC027AC9BE.heic](05(2)%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%80%E1%85%A8%E1%84%8E%E1%85%B3%E1%86%BC%209417e2dccd3b472a974c5d8d895c100d/48ba720b-e444-4e70-a10c-53007ea07624.png)

2.0 에서는 이것을 멀티플랙싱 기법을 도입해 완화했습니다. HTTP 멀티플 싱이란 여러 스트림을 이용해 병렬적으로 메시지를 주고 받는 기술을 의미합니다. 요청과 응답을 주고 받는 단위는 하나의 스트림에서 이루어지고 이러한 스트림을 여러개 활용하는 동시에 스트림 별로 독립적인 송수신이 가능하며 스트림 별 메시지들은 꼭 일정한 순서를 유지 할 필요가 없습니다 별도의 스트림을 통해 여러 데이터를 병렬적으로 주고 받는다면 HOL 블로킹을 상당 부분 완화할 수 있습니다

### HTTP/3.0

 앞선 http버전들은 모두 TCP를 기반으로 동작 하였습니다. 하지만 3.0은 이전까지의 http:// 버전과는 달리 UDT를 기반으로 동작합니다. 정확히 말하자면 UDT를 기반으로 구현 된 QUIC 프로토콜을 기반으로 동작합니다.

연결형 프로토콜인 TCP 에 비해 비 연결 형 프로토콜인 UDP는 상대적으로 더 빠르기 때문에 3.0은 속도 측면에서 큰 개선이 이루어졌습니다. 3.0은 현재 빠르게 성장하는 프로토콜로 이에 따라 QUIC의 중요성도 점점 커지고 있습니다.

# 05-3 HTTP 헤더와 HTPP 기반 기술

이번 절에서는 http메시지에 두 번째 줄인 필드 라인을 학습하겠습니다. 필드 라인에는 다양한 HTTP헤더들이 명시됩니다. HTTP헤더에는 필드이름(헤더이름)과 필드 값이 콜론(:)을 기준으로 구분되어 있습니다.

Http의 중요 헤더 중에서는 특별한 사전 지식이 필요하지 않은 헤더가 있고 사전 지식이 필요한 헤더가 있습니다. 예를 들어 캐시, 쿠키, 콘텐츠 협상 관련해서를 이해 하려면 먼저 캐시, 쿠키, 콘텐츠 협상이 무엇인지 이해해야 합니다. 우선 별도의 사전 지식 없이도 이해할 수 있는 http 해도들을 살펴 보고 그 뒤에 사전 지식이 필요한 http://헤더들을 학습하겠습니다.

## HTTP 헤더

### **요청시 활용 되는 HTTP 헤더**

---

HTTP 요청 시 주로 활용 되는 대표적인 헤더 ‘Host’, ‘User-Agent’, ‘Referer’, ‘Authorization’ 해더에 대해 알아보겠습니다.

<aside>
1️⃣

Host

Host는 요청을 보낼 호스트를 나타내는 헤더입니다.

주로 도메인 네임으로 명시 되며, 포트 번호가 포함되어 있을 수 있습니다

<aside>

GET /hypertext/WWW/TheProject.html HTTP/1.1

Host: info.cern.ch

…

</aside>

</aside>

<aside>
2️⃣

User-Agent

User-Agent(유저 에이전트)는 포스트 헤드와 더불어 HTTP요청 메시지 에서 가장 흔히 볼 수 있는 헤더 중 하나입니다. User-Agent란 웹 브라우저와 같이 HTTP요청을 시작하는 클라이언트측의 프로그램을 의미합니다.

 유저 에이전트 해도에는 이러한 정보 즉 요청 메시지 생성에 관련한 클라이언트 프로그램과 관련된 다양한 정보가 명시됩니다. 운영체제, 브라우저 종류 및 버전, 렌더링 엔진 과 같은 다양한 정보가 User-Agent헤더에 포함 되어 있습니다. 이를 통해 서버 입장에서.User-Agent 헤더를 통해 클라이언트의 접속 환경을 유출 할 수 있습니다.

</aside>

<aside>
3️⃣

Referer

Referer는 개발시 아주 유용한 헤더 중 하나입니다. 이 헤더에는 클라이언트가 요청을 보낼 때 머무르고 있던 URL이 명시됩니다. 다음 예시 해더는 클라이언트가 [https://en.wikipedia.org](https://en.wikipedia.org엣)에서 요청을 보냈음을 의미합니다. Referer를 통해 클라이언트의 유입 경로를 파악해 볼 수 있습니다.

<aside>

Referer: https://en/wikipedia.org/

</aside>

</aside>

<aside>
4️⃣

Authorization

Authorization 헤더는 클라이언트의 인증 정보를 담는 헤더입니다. 이해도에는 다음처럼 인증타입과 인증을 위한 정보가 차례로 명시됩니다. 인증 타입에 따라 인증 정보의 명시될 값이 달라집니다.

<aside>

Authorization: <type> <credentials>

</aside>

 인증 타입에 종류는 다양 하지만 가장 기본적인 HTTP인증 타입은 Basic이라는 타입입니다. 베이직 타임 인증은 username:password와 같이 사용자 아이디와 비밀번호를 콜론(:)을 이용해 합친 뒤, 이를 Base64 인코딩한 값을 인증 정보로 삼는 방식입니다. 여기서 Base64이란 ’문자를 코드로 변환 하는 방법’ 을 의미하는 인코딩 방식의 일종입니다.

</aside>

### **응답 시 활용되는 HTTP 해더**

---

HTTP 응답시 주로 활용 되는 대표적인 헤더는 Server, Allow, Retry-After, Location, WWW-Authenticate헤더 입니다.

<aside>
1️⃣

Server

Server 헤더는 요청을 처리 하는 서버 치게 소프트웨어 와 관련된 정보를 명시합니다.

다음 예시 해더는 Unix 운영체제에서 동작하는 아파치 HTTP서버를 의미합니다.

<aside>

Server: Apache/2.4.1 (Unix)

</aside>

</aside>

<aside>
2️⃣

Allow

Allow헤더는 클라이언트에게 허용된 HTTP메서드 목록을 알려 주기 위해 사용 됩니다.

앞 절에서 학습한 상태코드 405(요청한 메소드를 지원하지 않음)를 응답하는 메시지에서 Allow헤더가 함께 사용됩니다.

</aside>

<aside>
3️⃣

Retry-After

05-2에서 상태 코드 503(현재는 요청을 처리할 수 없으나 추후 가능할 수도 있음)도 학습했습니다. 응답과 함께 사용될 수 있는 헤더가 Retry-After헤더 입니다.

이 헤더는 자원을 사용할 수 있는 날짜 혹은 시각을 나타냅니다.

다음 예시는 각각’ 2024년 8월 23일 금요일 공 9시 이후에 사용 가능하다’ 라는 사실, ‘120 초 이후에 사용 가능하다’ 라는 사실을 나타내는 헤더입니다.

<aside>

Retry-After: Fri, 23 Aug 2024 09:00:00 GMT

Retry-After: 120

</aside>

</aside>

<aside>
4️⃣

Location

Location 헤더는 이전 절에도 언급했던 헤더로, 클라이언트에게 자원의 위치를 알려 주기 위해 사용되는 헤더입니다. 주로 리다이렉션이 발생했을 때 나 새로운 자원이 생성 되었을 때 사용합니다.

</aside>

<aside>
5️⃣

WWW-Authenticate

 요청한 자원에 대한 유효한 인증이 없을 때 응답 하는 코드 401 과 함께 사용되는 헤더가 WWW-Authenticate 입니다 WWW-Authenticate 헤더는자원의 접근 하기 위한 인증 방식을 설명하는 헤더 입니다. 이를테면 다음과 같이 베이직 인증을 요구할 수 있습니다.

<aside>

WWW-Authenticate: Basic

</aside>

다만 실제로는 이보다 조금 더 많은 정보를 알려 주는 경우가 많습니다. 예를 들어 다음과 같이 보안 영역을 함께 알려 주거나 인증에 사용될 문자 집합도 알려 줄 수 있습니다.

<aside>

WWW-Authenticate: Basic realm=”Access to engineering site”, charset=”UTF-8”

</aside>

<aside>
<img src="https://www.notion.so/icons/dialogue_red.svg" alt="https://www.notion.so/icons/dialogue_red.svg" width="40px" /> 영역(realm)이란?

</aside>

<aside>
<img src="https://www.notion.so/icons/alert_green.svg" alt="https://www.notion.so/icons/alert_green.svg" width="40px" /> WWW-Authenticate헤더에서 realm은 보안이 적용될 영역을 의미합니다. 영역이 달라지면 요구되는 권한도 달라질 수 있습니다. 예컨데 같은 서버가 제공하는 자원일지라도 Engineering site라는 영역에 속한 자원의 접근 가능한 사용자는 ‘Financial site’ 라는 영역에 속한 차원의 접근이 불가능할 수 있습니다.

</aside>

</aside>

<aside>
📚

Authorization과 WWW-Authenticate헤더를 통해 인증되지 않은 클라이언트가 HTTP인증을 수행하는 과정을 살펴보겠습니다.

1. 인증되지 않은 클라이언트가 서버에 GET 요청 메세지를 전송합니다.
2. 서버는 클라이언트에게 상태코드 401과 함께 WWW-Authenticate 헤더를 통해 인증 방식을 알립니다.
3.  클라이언트는 사용자로부터 인증 정보(사용자 아이디와 비밀번호)를 전달 받습니다.
4. “사용자 아이디: 비밀번호” 를 Base64 인코딩한 값을 인증 정보로 삼은 Authorization 헤더를 통해 다시 GET 요청 메시지를 전송합니다.
5. 서버는 인증 정보를 확인합니다.
6. 인증이 유효하면 상태 코드 200으로 응답 하고, 인증되지 않았으면 상태코드 401로 응답 합니다.

![C7D54367-4DE6-4FB4-9BD2-F7B43FD3EF24_1_201_a.heic](05(2)%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%80%E1%85%A8%E1%84%8E%E1%85%B3%E1%86%BC%209417e2dccd3b472a974c5d8d895c100d/C7D54367-4DE6-4FB4-9BD2-F7B43FD3EF24_1_201_a.heic)

</aside>

## 요청과 응답 모두에서 활용되는 HTTP헤더

---

HTTP 응답과 요청 모두에서 공통으로 활용 되는 HTTP해더들도 알아보겠습니다.

<aside>
1️⃣

Date

Date는 메시지 가 생성된 날짜와 시각에 관련된 정보를 담은 해더입니다. 클라이언트와 서버 모두에서 사용될 수 있는 헤더입니다.

<aside>

Date: Tue, 15 Nov 1994 08:12:31 GMT

</aside>

</aside>

<aside>
2️⃣

Connection

Connection 헤더는 클라이언트의 요청과 응답 간의 연결 방식을 설정하는 헤더입니다.
Http의 특성을 학습 할 때 http를 지속 연결 프로토콜이라 언급했습니다. 지속 연결을 킵 얼라이브라고도 부릅니다.

이 지속 연결이 Connection에 명시되는 대표적인 연결 방식입니다. ‘Connection: keep-alive’헤더를 통해 상대방에게 지속 연결을 희망함을 알릴 수 있습니다. 또한 서버나 클라이언트가 연결을 종료하고 싶을 때는 ‘Connection: close’를 통해 알릴 수도 있습니다. Connection필드에는 다양한 값이 명시될 수 있지만, 가장 대표적으로 사용되는 값은 keep-alive와 close입니다.

<aside>

Connection: keep-alive

Connection: close

</aside>

</aside>

<aside>
3️⃣

Content-Length

본문의 바이트 단위 크기(길이)를 나타냅니다.

<aside>

Content-Length: 100

</aside>

</aside>

<aside>
4️⃣

Content-Type, Content-Lanquage, Content-Encoding

이 헤더들은 전송하려는 메시지 본문의 표현 방식을 설명하는 헤더입니다. 이런 점에서 이 헤더들을 `표현 헤더` 의 일종이라고도 부릅니다. HTTP요청-응답 메시지를 관찰하다보면 자주 접하게 되는 헤더들입니다.

- Content-Type 헤더는 메시지 본문에서 사용된 미디어 타입을 담고 있습니다.
- Content-Lanquage 헤더는 메시지 본문에 사용된 자연어를 명시합니다.
    
    Content-Lanquage의 값은 언어 태그로 명시되며 언어 태그는 하이픈(-)으로 구분된 구조를 따릅니다.
    
    <첫 번째 서브 태그>-<두 번째 서브태그>-<세 번째 서브태그>…
    

| 언어 | 한국어 | 영어 | 중국어 | 일본어 | 독일어 | 프랑스어 |
| --- | --- | --- | --- | --- | --- | --- |
| 언어 코드 | ko | en | zh | ja | de | fr |

| 국가 | 한국 | 미국 | 영국 | 중국 | 타이완 | 일본 | 독일 | 프랑스 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 국가 코드 | KR | US | GB | CN | TW | JP | DE | FR |

국가코드는 대문자를 사용하는 것이 일반적

- Content-Encoding 헤더는 메시지 본문을 압축하거나 변환한 방식이 명시됩니다.
    
    e http를 통해 송수신 되는 데이터는 전송 속도를 개선하기 위해 종종 압축이나 변환이 되고는 하는데, 이때 사용된 방식이 Content-Encoding 필드의 명시 되는 셈입니다. 수신 책은 이해도를 통해 압축 및 변환 방식을 인식하고 압축을 해제하거나 원문으로 변환하여 본문 내용을 확인할 수 있게 됩니다.
    
    Content-Encoding 헤더의 명시 될 수 있는 대표적인 값은 ‘gzip’, ‘compress’, ‘deflate’, ‘br’등이 있습니다.
    
</aside>

## 캐시

 클라이언트가 이미지를 조회 하기 위해서 서버를 향해 GET 요청 메시지를 보냈고 이에 대한 응답 메시지로 10MB 크기의 이미지가 클라이언트에게 전송 되었다고 가정해 봅시다. 그런데 이 때 클라이언트가 같은 이미지를 두번 세번 더 요청 하면 어떻게 될까요? 

오늘 날에 인터넷 환경에서는 HTTP 캐시 (혹은 웹 캐시) 를 활용해 응답 받은 내용에 사본을 임시로 저장할 수 있습니다.

<aside>
<img src="https://www.notion.so/icons/dialogue_red.svg" alt="https://www.notion.so/icons/dialogue_red.svg" width="40px" /> 캐시란?

</aside>

<aside>
<img src="https://www.notion.so/icons/alert_green.svg" alt="https://www.notion.so/icons/alert_green.svg" width="40px" /> 불필요한 대역폭 낭비와 응답 지연을 방지하기 위해 정부의 사본을 임시로 저장 하는 기술을 뜻합니다.

정보의 사본을 임시로 저장하는 것 자체를 캐쉬 한다. 캐 싱 한다. 라고도 표현 하며 캐쉬 된 데이터를 캐쉬라 부르기도 합니다. 이렇게 사본을 임시로 저장해 두면 동일한 요청에 대해 캐쉬 된 데이터를 활용할 수 있기 때문에 불필요한 대역폭 낭비를 줄일 수 있고 더 빠르게 데이터에 접근할 수 있습니다.

</aside>

 캐쉬는 웹 브라우저의 저장 되어 있기도 하고 클라이언트와 서버 사이에 위치한 중간 서버에 저장 되어 있기도 합니다.

웹 브라우저의 저장 되어 있는 것을 개인 전용 개시 중간 서버에 저장되어 있는 것을 공통 캐쉬 라고 부릅니다.

 캐시에서 중요한 점은 바로 캐쉬는 원본이 아닌 사본을 저장 한다는 것입니다. 원본이 아니라는 말이죠. 따라서 캐쉬를 했다면 항상 캐시한 이후로 원본 데이터가 변경 되는 상황에 대비 해야 합니다. 만약 원본 데이터가 변경 되었는데도 계속해서 캐쉬 된 사 본 데이터를 참조 하다 보면 문제가 발생할 수 있습니다.

캐쉬 된 사 본 데이터가 얼마나 최신 원본 데이터와 유사한 지를 캐쉬 신선도 라고 표현 하기도 합니다. 이 캐쉬 신선도를 유지하는 가장 기본적인 방법은 캐쉬 된 데이터의 유효기간을 설정 하는 것입니다. 캐시 된 데이터를 한 달 뒤 1년 뒤 10년 뒤든 언제까지고 참조 할 수 있다면 자연스럽게 신선도는 떨어질 수밖에 없습니다. 따라서 캐시 데이터의 유효기간을 설정하고 기간이 만료 되었다면 원본 데이터를 다시 요청 하는 방식으로 캐쉬 신선도를 유지할 수 있습니다.

캐쉬 데이터의 유효기간을 부여 하는 방법으로는 응답 메시지의 Expires헤더(날짜)와 Cache-Control헤더의 Max-Age값(초)을 사용할 수 있습니다.

아래 사진 속 붉은색 글자를 통해 확인할 수 있습니다. 각각 캐시의 유효 시간을 2024년 2월 6일 화요일 12:00:00 으로 설정하고 1200 초로 설정 하는 응답 메시지 예시 입니다.

![19857E18-7731-4AA1-8EBB-48BF696DFCC6_1_102_a.jpeg](05(2)%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%80%E1%85%A8%E1%84%8E%E1%85%B3%E1%86%BC%209417e2dccd3b472a974c5d8d895c100d/19857E18-7731-4AA1-8EBB-48BF696DFCC6_1_102_a.jpeg)

클라이언트가 응답받은 자원을 캐시해서 이용하다가 캐시의 유효 기간이 만료되었다고 가정해 보겠습니다. 그렇다면 서버에게 자원을 다시 요청해야겠죠. 그런데 만약 캐시의 유효 기간이 만료되었더 라도 원본 데이터가 변하지 않았다면 서버는 굳이 같은 자원을 전송해 줄 필요가 없습니다. 어차피 같은 자원이 클라이언트에게 캐시되어 있으니까요. 다시 말해, 캐시가 만료되었더라도 캐시된 자원 이 여전히 최신 정보라면 클라이언트는 굳이 서버로부터 같은 자원을 응답받을 필요가 없습니다. 캐 시된 자원을 (유효 기간을 연장하여) 이용하면 되니까요. 하지만 만일 서버의 원본 자원이 변경되었 다면 클라이언트는 새로운 자원을 응답받아야 합니다.
따라서 캐시의 유효 기간이 만료되었다면 클라이언트는 캐시된 자원이 여전히 신선한지, 여전히 최신 상태의 정보인지 재검사해야 합니다. 캐시의 신선도를 재검사하는 방법은 크게 두 가지 방법이 있 습니다. 하나는 '날짜를 기반으로 서버에게 물어보는 방법'이고, 또 다른 하나는 '엔티티 태그를 기반 으로 서버에게 물어보는 방법'입니다.
날짜를 기반으로 재검사하는 방식을 먼저 살펴봅시다. 클라이언트는 If-Modified-Since 헤더를 통해 서버에게 특정 시점 이후로 원본 데이터에 변경이 있었는지 물어볼 수 있습니다. If-Modified-Since 헤더의 값으로 특정 시점(날짜와 시각)이 명시되는데, 이 시점 이후로 원본에 변 경이 있었다면 그때만 새 자원으로 응답하도록 서버에게 요청하는 헤더입니다.

다음 예시를 통해서 이해해 봅시다. 해당 요청 메시지는 2024년 8월 23일 금요일 09:00:00 이후에 www.example.com/index.html의 자원이 변경되었니? 변경이 되었을 경우에만 새 자원으로 응답해 줘'라는 요청 메시지와 같습니다.

<aside>

요청 메시지

GET /index.html HTTP/1.1

Host: www.example.com

If-Modified-Since: Fri, 23 Aug 2024 09:00:00 GMT

</aside>

자, 이제 서버 입장에서 생각해 봅시다. 서버가 I-Modified-Since 헤더가 포함된 요청 메시지를 수신했다고 가정해 봅시다. 이때 서버의 자원은 크게 셋 중 하나의 상황을 따르게 됩니다.

1. 요청받은 자원이 변경되었음
2. 요청받은 자원이 변경되지 않았음
3. 요청받은 자원이 삭제되었음

첫째, 요청받은 자원이 변경되었다면, 서버는 상태 코드 200(OK)과 함께 새로운 자원을 반환합니다.

둘째, 요청받은 자원이 변경되지 않았다면, 서버는 메시지 본문 없는 상태 코드 304(Not Modified)를 통해 클라이언트에게 자원이 변경되지 않았음을 알립니다. 이 경우 클라이언트는 캐시된 자원을 사용할 수 있습니다.

셋째, 만약 요청받은 자원이 삭제되었다면, 서버는 상태 코드 404(Not Found)를 통해 요청한 자원이 존재하지 않음을 알립니다.

05-2에서 300번대 상태 코드를 설명할 때 상태 코드 304(Not Modified)는 다음 절에서 설명할 예정이라고 언급했었지요? 여러분이 HTTP 응답 상태 코드 304(Not Modified)를 마주친다면, 이 는 십중팔구 이미 캐시된 자원이 있으니 캐시된 자원을 참조하세요'라는 응답일 것입니다

서버는 상태 코드 304(Not Modified)를 통한 자원의 변경 여부'뿐만 아니라 자원의 마지막 변경 시점'도 클라이언트에게 알려 줄 수 있습니다. 이를 위한 헤더로 Last-Modified 헤더가 있습니다.
즉, Last-Modified 헤더는 특정 자원이 마지막으로 수정된 시점을 나타냅니다. 위 화면 속 Last-Modified 헤더를 확인해 보세요. 응답된 자원이 마지막으로 2019년 10월 17일 목요일 7시 18분
26초에 변경되었음을 나타냅니다.

22222

지금까지 날짜를 기반으로 캐시 신선도를 재검사하는 방식을 설명했다면, 이번에는 엔티티 태그 5 7a(이하 E(ag)를 사용하는 방법에 대해 알아보겠습니다. Itag는 자원의 버전을 식별하기 위한 정보 입니다. 여기서 버전: 이란 유의미한 변경 사항을 의미합니다. 즉, 자원이 변경될 때마다 자원의 버전을 식별하는 Eag 값이 변경됩니다. 반대로 자원이 변경되지 않았다면 Btag 값도 변경되지 않습니다.

클라이언트가 Btag 값이 부여된 자원을 캐시할 때 캐시 신선도를 검사하기 위해 서버에게 '이 Bag

값과 일치하는 자원이 있니?와 같이 물어볼 수 있습니다. 이를 위해 사용하는 헤더가 바로 IF-None-Match 입니다. 예를 들어 다음의 요청 메시지는 '혹시 Etag 값이 abe www.example.

com/index.html이라는 자원이 있니? 이 자원이 변경되었다면(Btag 값이 바뀌었다면) 그때만 새 자원으로 응답해 줘'라는 요청 메시지와 같습니다.

<aside>

요청메시지

GET /index.html HTTP/1.1

Host: www.example.com

If-None-Match: "abc"

</aside>

이때도 서버의 자원은 크게 셋 중 하나의 상황을 따릅니다.

1. 요청받은 자원이 변경되었음(Etag 값이 변경됨)
2. 요청받은 자원이 변경되지 않았음(Etag 값이 동일함)
3. 요청받은 자원이 삭제되었음

첫째로, 요청한 자원이 변경되었다면 Blag 값도 변경되었을 것입니다. 이 경우 서버는 상태 코드 200(OK)과 함께 변경된 데이터와 Brag 값을 응답합니다.

둘째로, 요청한 자원이 변경되지 않았다면 Btag 값도 변하지 않았겠죠. 이때 서버는 메시지 본문 없는 상태 코드 304(Not Modified)를 응 답합니다.

셋째로, 요청한 자원이 삭제되었다면 서버는 상태 코드 404(Not Found)를 응답하게 됩 니다.

## 쿠키

HTTP는 기본적으로 상태를 유지하지 않는 스테이트리스 프로토롤입니다.

그런데 만약 HTTP가 스테이트리스 프로토콜이고 클라이언트의 상태를 유지하지 않는다면, 오늘은 그만보기, 로그인 상태 유지등 과 같은 기능은 어떻게 구현되는 것일까요?

HTTP 쿠키(이하 쿠키)를 통해 이러한 기능을 구현할 수 있습니다.

<aside>
<img src="https://www.notion.so/icons/dialogue_red.svg" alt="https://www.notion.so/icons/dialogue_red.svg" width="40px" /> 쿠키(cookie)란?

</aside>

<aside>
<img src="https://www.notion.so/icons/alert_green.svg" alt="https://www.notion.so/icons/alert_green.svg" width="40px" /> 서버에서 생성되어 클라이언트 측에 저장되는 데이터로, 상태를 유지하지 않는 HTTP의 특성을 보완하기 위한 수단입니다.

</aside>

서버가 클라이언트의 상태를 알 수 있게끔 하는 특별한 데이터지요. 쿠키를 이루는 정보는 기 본적으로 <이름, 값> 쌍의 형태를 띠고 있고, 추가로 적용 범위와 만료 기간 등 다양한 속성을 가질 수 있습니다.

서버는 쿠키를 생성하여 클라이언트에게 전송하고, 클라이언트는 전달받은 쿠키를 저장해 두었다가 추후 동일한 서버에 보내는 요청 메시지에 쿠키를 포함하여 전송합니다. 서버는 쿠키 정보를 참고해 두 개의 요청이 같은 클라이언트에서 왔는지, 로그인 상태를 유지하고 있는지 등을 알 수 있습니다.

<aside>
⚠️

세션인증

HTTP는 스테이트리스 프로토콜이라고 했습니다. 같은 클라이언트가 서버에 여러 번 요청을 보낸다고 해도, 기본적으로 서 버는 모든 요청들을 별개의 요청으로 간주하지요. 그렇다면 클라이언트가 서버에 요청 메시지를 보낼 때마다 (아이디, 비밀 번호와 같은) 인증 정보를 보내고 번거로운 인증 과정을 거쳐야 하는 것일까요? 그렇지 않습니다.

쿠키를 통해 전달되는 대표적인 정보로 세션 아이디(session id)가 있습니다. 세션 아이디란 무엇일까요? 세션 아이디가 무엇인지 이해하려면 세션 인증(session authentication)이 무엇인지 이해해야 합니다. 세션 인증이란 다음과 같은 순서 로 이루어지는 인증 방식을 의미합니다.

1. 클라이언트는 서버에게 (아이디, 비밀번호와 같은) 인증 정보를 전송합니다.
2. 인증 정보가 올바르다면, 서버는 세션 아이디를 생성해 클라이언트에게 전송합니다.
3. 서버는 생성한 세션 아이디를 데이터베이스 등에 저장합니다.
4. 클라이언트는 추후 요청을 보낼 때 쿠키 내에 세션 아이디를 포함하여 전송합니다.
5. 서버는 쿠키 속 세션 아이디와 저장된 세션 아이디를 비교하여 클라이언트를 식별합니다.

위와 같이 쿠키를 통해 세션 아이디를 전송하면 요청을 보낼 때마다 번거로운 인증 과정을 거칠 필요가 없어서 효율적입니다.

</aside>

앞서 언급했듯이 쿠키는 서버가 생성하고, 클라이언트는 서버로부터 전달받은 쿠키를 활용합니다.
이들은 각각 응답 메시지의 Set-Cookie 헤더와 요청 메시지의 Cookie 헤더를 통해 전달됩니다.

### 응답 메시지

응답 메시지의 Set-Cookie 헤더를 통해 쿠키의 이름, 값과 더불어 세미콜론(;)으로 구분되는 속성(들)을 전달할 수 있습니다. 한 응답 메시지에 전달할 쿠키가 여러 개라면 다음과 같이 여러 개의 Set-Cookie를 사용하기도 합니다.

<aside>

Set-Cookie: 이름=값
Set-Cookie: 이름=값; 속성1
Set-Cookie: 이름=값; 속성1; 속성2

</aside>

요청 메시지의 Cookie 헤더 값은 서버에 전달할 쿠키의 이름과 값을 나타내는 헤더입니다. 여러 개 의 쿠키 값을 서버에 전달해야 할 때는 다음과 같이 세미 콜론(;)을 사용하여 여러 쿠키의 이름 값을 나타낼 수 있습니다.

요청메시지

<aside>

Cookie: 이름=값; 이름=값;

</aside>

다음 예시 메시지를 봅시다. 첫 번째 메시지는 name=minchur, phone="100-100”, mesage="Hello"라는 쿠키를 클라이언트에게 전송하는 서버의 응답 메시지 예시입니다. 두 번째 메시지는 서버로부터 전달받은 쿠키를 활용하는 클라이언트의 요청 메시지 예시입니다.

응답 메시지

<aside>

HTTP/1. 1 200 0K

Content-Type: text/html

Set-Cookie: name=minchul

Set-Cookie: phone=100-100

Set-Cookie: message=Hello

... 헤더 후략…

…메시지 본문 생략…

</aside>

요청메시지

<aside>

GET /next_page HTTP/1.1
Host: [example.com](http://example.com/)
Cookie: name-minchul; phone=100-100; message=Hello

...헤더 후략...

</aside>

쿠키는 브라우저에서 저장되고 관리됩니다. 크롬 브라우저에서 개발자 도구를 열고, [Application] - [storage] - [Cookies]를 확인해보면 다음 화면처럼 쿠키의 이름Namg, 값Value 목록을 볼 수 있을 것입니다. 각각의 행이 쿠키인 셈입니다.

쿠키 관련 정보로 이름Name과 값Vale 외에도 도메인Domain과 경로(Path) 등도 있습니다.

www.naver.com에게 받은 쿠키를 전혀 다른 웹 사이트인 www.google.com에게 전송하면 안 되듯이, 쿠키는 사용 가능한 도메인이 정해져 있습니다. 이는 응답 메시지 속 Set-Cookie 헤더의'domain 속성으로 정해집니다.

응답 메시지

<aside>

Set-Cookie: name=minchul [domain=example.com](http://domain=example.com/)

</aside>

또한 같은 도메인이라도 경로별로 쿠키를 구분하여 사용하고 싶을 때가 있을 수 있습니다. 예를 들 어 www.example.com/lectures를 포함한 하위 경로에서 사용하고자 하는 쿠키와 www.example.com/books를 포함한 하위 경로에서 사용하고자 하는 쿠키가 다를 수 있습니다. 이럴 때는 "path"로 쿠키가 적용될 경로를 명시하면 됩니다. 그러면 path로 지정된 경로와 그 앞부분이 일치하는 경로(하위 경로)에서 해당 쿠키 정보를 활용 할 수 있게 됩니다.

응답 메시지

<aside>

Set-Cookie: name=minchul path=/lectures

</aside>

Expires/Max-Age라는 열도 있습니다. 이는 쿠키의 유효 기간을 나타냅니다. 쿠키마다 보통 유효기간이 정해져 있습니다. Expires는 [요일, DD-MM-YY HH:MM:SS GMT]형식으로 표기되는 쿠키 만료 시점을 의미하고, Max-Age는 초 단위 유효 기간을 의미합니다. Expires로 명시된 시점이 지나거나 Max-Age로 명시된 유효 기간이 지나면 해단 쿠키는 삭제되어 전달되지 않습니다.

<aside>

Set-Cookie: sessionID=abc123; Expires-Fri, 23 Aug 2024 09:00:00 GMT
Set-Cookie: sessionID=abc123; Max-Age=2592000

</aside>

쿠키를 학습할 때는 쿠키의 한계도 알아두는 것이 좋습니다.

쿠키의 대표적인 한계는 바로 `보안`입니다.

쿠키에 개인 정보를 비롯해 보안에 민감한 정보를 담아 송수신하고 저장하는 것이 바람직하지 않습니다. 쿠키 정보가 쉽게 노출되거나 조작될 수 있기 때문입니다. 이를 보완하기 위한 속성으로 Secure와 HttpOnly라는 속성이 있습니다.

`Secure`는 HTTPS 프로토콜이 사용되는 경우에만 쿠키를 전송되도록 하는 속성입니다. 7장에서 학습할 예정이지만, HTTPS 프로토콜은 HTTP를 더 안전한 방식으로 전송할 수 있는 프로토콜입니다.
`HtpOnly`는 HTTP 송수신을 통해서만 쿠키를 이용하도록 제한하는 속성입니다. 지금까지 설명한 바에 따르면 쿠키는 HTTP 헤더를 통해 송수신되었죠? 다시 말해 쿠키와 관련한 데이터는 HTTP 송수신을 통해서만 확인이 가능했습니다. 그런데 사실 쿠키 관련 데이터는 자바스크립트 라는 언어를 통해서도 접근 가능합니다. 악의적 의도를 가진 해커는 (정상적인 HTTP 송수신을 통해서가 아닌) 자바스크립트로 쿠키를 중간에 가로채거나 위변조할 수 있습니다. HttpOnly는 이런 상황을 방지하기 위해 자바스크립트에서 쿠키에 접근하지 못하도록 하는 속성입니다. 자바스 크립트에 대해 잘 모르는 독자라면 HttpOnly는 쿠키의 위변조를 방지하기 위한 속성이다 정도 로만 이해해도 무방합니다.

<aside>
⚠️

웹 스토리지: 로컬 스토리지와 세션 스토리지

쿠키는 서버가 생성하고 클라이언트가 저장하는 정보입니다. 이를 통해 클라이언트의 상태를 추측할 수 있습니다. 쿠키 이외 에도 클라이언트가 저장하고 클라이언트의 상태를 추측할 수 있는 <키 값> 쌍 형태의 정보가 있습니다. 바로 웹 스토리지 (web storage)입니다. 웹 스토리지는 웹 브라우저 내의 저장 공간으로, 일반적으로 키보다 더 큰 데이터를 저장할 수 있 습니다. 또 쿠키는 서버로 자동 전송되지만, 웹 스토리지의 정보는 서버로 자동 전송되지 않습니다. 필요할 때 조회할 수 있지요.
웹 스토리지에는 크게 로컬 스토리지(ocal storage)와 세션 스토리지(session storage)가 있습니다. 개발자 도구를 열고 [Application] - [Storage]를 보면 로컬 스토리지와 세션 스토리지를 확인할 수 있습니다.

</aside>

## 콘텐츠 협상과 표현

국에서 접속하거나 한국어 계정으로 특정 URL에 접속하면 한국어로 된 웹 페이지를 볼 수 있고, 다른 지역에서 접속하거나 영어 계정으로 같은 URL에 접속하면 영어로 된 웹 페이지를 볼 수 있는 상황이 있습니다.

클라이언트가 서버에 자원을 요청하고, 서버는 요청받은 자원을 응답한다고 있습니다. 그리고 자원은 URI를 통해 식별 가능하다고도 했지요. 분명 같은 자원을 요청했는데 어떻게 다른 결과를 얻는 것일까요?

이는 HTTIP의 콘텐츠 협상(colo oonion을 통해 이루어집니다.
`콘텐츠 협상`이란, 같은 URI에 대해 가랑 적합한 자원의 형태를 제공하는 메커니즘을 의미합니다. 같은 URI로 식별 가능한 HTML 문서라 해도, 영어로 요청하면 영어로 된 형태로 제공하고, 한국어로 요청하면 한국어로 된 형태를 제공하는 것이지요.

이때. 송수신 가능한 자원의 형태를 자원의 표현이라고 합니다. 즉, 콘텐츠 협상은 클라이언트에게 가장 적합한 자원의 표현을 제공하는 메커니즘을 의미합니다.

표현이 무엇인지 배웠다면, 이를 고려하여 앞서 배운 GET 메서드를 조금 더 엄밀하게 정의할 수 있 습니다. 이전에는 GET 메서드를 자원을 습득하기 위한 메서드'라 정의했습니다. 하지만 이제는 자 원에 대한 다양한 표현이 가능하고, 클라이언트가 습득하는 것은 다양한 표현 중 하나라는 점을 알았습니다. 그렇다면, GET 메서드는 '자원의 특정 표현을 습득하기 위한 메서드'라 정의할 수 있을 것입니다. 실제로도 GET 메서드의 공식적인 정의는 다음과 같습니다.

> requests transfer of a current selected representation for the target resource.
대상 자원에 대해 현재 선택된 표현의 전송을 요청합니다.
> 

다시 콘텐츠 협상 이야기로 돌아와 보겠습니다. 자원에 대한 다양한 표현 중에서 클라이언트가 선호 하는 표현을 반영하고자 콘텐츠 협상 관련 HTTP 헤더들이 사용됩니다. 주요 헤더로는 선호하는 미디어 타입을 나타내기 위한 Accept 헤더, 선호하는 언어를 나타내기 위한 Accept-Language 헤 더, 선호하는 문자 인코딩과 압축 방식을 나타내기 위한 Accept-Charset 및 Accept-Encoding 헤더 등이 있습니다.

예를 들어 클라이언트가 선호하는 언어가 한국어일 경우, Accept-Language: ko를 헤더에 추가 하여 서버에 요청하면 됩니다. 그러면 서버는 클라이언트가 선호하는 언어를 인식하여 한국어로 표 현된 자원을 보내 주게 됩니다. 또한 클라이언트가 HTML 문서 타입을 선호한다면 헤더에 Accept:text/html을 추가하여 서버에 요청하면 됩니다. 아래 요청 메시지는 이러한 콘텐츠 협상 헤더들을 사용해 서버에게 요청을 보낸 예시입니다.

요청 메시지

<aside>

GET /index.html HTTP/1.1
Host: [example.com](http://example.com/)
Accept-Language: ko
Accept: text/html

</aside>

콘텐츠 협상에서 중요한 점은 선호도에 우선순위를 반영할 수 있다는 점입니다. 예를 들어 클라이언트가 `'언어는 한국어를 가장 선호하지만, 영어도 받을 용의가 있다'`라는 식으로 여러 선호도를 담은 요청 메시지를 보낼 수도 있습니다. 혹은 `‘미디어 타입은 HTML 문서를 가장 선호하지만, XML을 그 다음으로 선호하고, 일반 텍스트를 그 다음으로 선호한다'`라는 식으로 여러 선호도를 담은 요청 메시 지를 보낼 수도 있습니다.

이러한 우선순위는 콘텐츠 협상 관련 헤더의 q값으로 표현됩니다. q는 Quality Value의 약자로, 특정 표현을 얼마나 선호하는지를 나타내는 값입니다. 생략되었을 경우에는 1을 의미하고, 범위는 0 부터 1까지이며, 값이 클수록우선순위가 높습니다.

아래 요청 메시지는 방금 설명한 예시에 대한 요청헤더입니다.
한국어(ko-KR, ko), 영어(en-US, en)순으로 선호하고, HTML, XML, 일반 텍스트순으로 선호한다는 것을 알 수 있습니다.

요청 메시지

<aside>

GET /index.html HTTP/1.1
Host: [example.com](http://example.com/)
Accept-Language: ko-KR, ko; q=0.9, en-US; q=0.8, en; q=0.7
Accept: text/html, application/xml;q=0.9, text/plain;q=0.6,*/*;q=0.5

</aside>
